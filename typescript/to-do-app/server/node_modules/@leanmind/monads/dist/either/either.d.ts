import { Monad } from '../monad';
import { Matchable } from '../match';
declare abstract class Either<L, R> implements Monad<R>, Matchable<R, L> {
    static right<T>(value: T): Either<never, T>;
    static left<T>(value: T): Either<T, never>;
    static from<L, R>(matchable: Matchable<R, L>): Either<L, R>;
    static catch<T>(execute: () => T): Either<Error, T>;
    abstract map<T>(f: (r: R) => T): Either<L, T>;
    abstract mapLeft<T>(f: (l: L) => T): Either<T, R>;
    abstract flatMap<T>(f: (r: R) => Either<L, T>): Either<L, T>;
    abstract flatMapLeft<T>(f: (l: L) => Either<T, R>): Either<T, R>;
    abstract match<T>(ifRight: (r: R) => T, ifLeft: (l: L) => T): T;
    abstract isLeft(): this is Left<L, R>;
    abstract isRight(): this is Right<L, R>;
}
declare class Left<L, R> extends Either<L, R> {
    private value;
    constructor(value: L);
    map<T>(_: (r: R) => T): Either<L, T>;
    mapLeft<T>(f: (l: L) => T): Either<T, R>;
    flatMap<T>(_: (r: never) => Either<L, T>): Either<L, T>;
    match<T>(_: (_: never) => never, ifLeft: (l: L) => T): T;
    isLeft(): this is Left<L, R>;
    isRight(): this is Right<L, R>;
    flatMapLeft<T>(f: (l: L) => Either<T, R>): Either<T, R>;
}
declare class Right<L, R> extends Either<L, R> {
    private value;
    constructor(value: R);
    map<T>(f: (r: R) => T): Either<L, T>;
    mapLeft<T>(_: (l: L) => T): Either<T, R>;
    flatMap<T>(f: (r: R) => Either<L, T>): Either<L, T>;
    match<T>(ifRight: (r: R) => T, _: (_: never) => never): T;
    isLeft(): this is Left<L, R>;
    isRight(): this is Right<L, R>;
    flatMapLeft<T>(_: (l: never) => Either<T, R>): Either<T, R>;
}
export { Either, Right, Left };
