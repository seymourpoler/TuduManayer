class Option {
    static of(value) {
        if (value == null) {
            return new None();
        }
        return new Some(value);
    }
    static from(matchable) {
        return matchable.match((value) => Option.of(value), () => Option.of(undefined));
    }
}
class Some extends Option {
    value;
    constructor(value) {
        super();
        this.value = value;
    }
    getOrElse(_) {
        return this.value;
    }
    filter(predicate) {
        return predicate(this.value) ? new Some(this.value) : new None();
    }
    map(transform) {
        return new Some(transform(this.value));
    }
    flatMap(transform) {
        return transform(this.value);
    }
    match(some, _) {
        return some(this.value);
    }
    isNone() {
        return false;
    }
    isSome() {
        return true;
    }
}
class None extends Option {
    getOrElse(value) {
        return value;
    }
    filter(_) {
        return new None();
    }
    map(_) {
        return new None();
    }
    flatMap(_) {
        return new None();
    }
    match(_, none) {
        return none(undefined);
    }
    isNone() {
        return true;
    }
    isSome() {
        return false;
    }
}
export { Option, Some, None };
